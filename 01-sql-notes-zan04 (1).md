# Въведение в SQL

## Основни понятия

* SQL - език за  съставяне на заявки към сървъри за бази данни (БД)
* всяка БД се състои от множество таблици, в които се намират даните
* всяка таблица съответства на определен обект от модела на БД
* обект в модела на БД е нещо, за което събираме данни: Продукти, Коментари,
      Потребители, Плащания и т.н.

* **първичен ключ** (PK - Primary Key) e уникалният за дадена таблица 
идентификатор на редовете. НЕ СЕ ПОВТАРЯ

  (pk)  user                   (pk)     posts
+-----+-----------+           +----+----------------+
| UID | UserName  |           | PID| Post           |
+-----+-----------+           +----+----------------+
|  1  |  John     |           | 1  |Hello ...       |
+-----+-----------+           +----+----------------+
|  2  |  Maria    |           | 2  |MySQL is...     |
+-----+-----------+           +----+----------------+
|  3  |  Peter    |           | 3  |SQL query...    |
+-----+-----------+           +----+----------------+
|  4  |  Anna     |           | 4  |Oracle driver...|
+-----+-----------+           +----+----------------+

* **външен ключ** (FK - Foreign Key) e идентификатор, който задава съответствието
на редовете от една таблица към друга таблица. ст-стите може да се повтарят 

  (pk)  user                   (pk)     posts        (fk)
+-----+-----------+           +----+----------------+------+
| UID | UserName  |           | PID| Post           | UID  |
+-----+-----------+           +----+----------------+------+
|  1  |  John     |           | 1  |Hello ...       |  1   |
+-----+-----------+           +----+----------------+------+
|  2  |  Maria    |           | 2  |MySQL is...     |  2   |
+-----+-----------+----------<-----+----------------+------+
|  3  |  Peter    |           | 3  |SQL query...    |  1   |
+-----+-----------+           +----+----------------+------+
|  4  |  Anna     |           | 4  |Oracle driver...|  2   |
+-----+-----------+           +----+----------------+------+


### Връзки между таблиците 

* 1:М -> на един ред от А съответстват един или повече реда от B
* 1:1 -> на един ред от А съответства точно един ред от B
* M:N -> на един ред от А съответстват един или повече реда от B, обратното 
             също е вярно; обикновено се преработва до 1:M и N:1
 


### Референциална цялост на БД (интегритет)

С данните могат да бъдат извършвани четири основни опрации:

* ЧЕТЕНЕ на **данни**
* ДОБАВЯНЕ на **редове** 
* ПРОМЯНА на **данни** (рестриктивно/каскадно)
* ИЗТРИВАНЕ на **редове** (рестриктивно/каскадно)

ЧЕТЕНЕТО на данни няма отношение към референциалната цялост, тъй като при тази 
операция не се променя съдържанието на таблиците

При ДОБАВЯНЕ определя последователността на действията (1. добавя се ред от 
страната 1; 2. добавя се ред от страната М).

За ПРОМЯНА/ИЗТРИВАНЕ интегритета може да се поддържа по два начина: рестриктивно
или каскадно.

  (pk)  user                   (pk)     posts        (fk)
+-----+-----------+           +----+----------------+------+
| UID | UserName  |           | PID| Post           | UID  |
+-----+-----------+           +----+----------------+------+
|  1  |  John     |           | 1  |Hello ...       |  1   |
+-----+-----------+           +----+----------------+------+
|  2  |  Maria    |           | 2  |MySQL is...     |  2   |
+-----+-----------+----------<+----+----------------+------+
|  3  |  Peter    |           | 3  |SQL query...    |  1   |
+-----+-----------+           +----+----------------+------+
|  4  |  Anna     |           | 4  |Oracle driver...|  2   |
+-----+-----------+           +----+----------------+------+


## Модел на базата данни Northwind
(чувствителност към регистър на три нива: 1, ниво сесия, 2. ниво таблица
настройва се от tools-pref-db-nls, като somparesion чувствително, linguistic - не чувст.

```
1. https://www.oracle.com/technetwork/database/database-technologies/express-edition/downloads/xe-prior-releases-5172097.html
2. http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html
 ако се наложи 
 2.1. http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

3. https://notepad-plus-plus.org/download/v7.7.1.html

```

## SQL - Structured Query Language

* езикът SQL се състои от две групи изрази: DDL и DML.

### DDL - Data Definition Language 

* CREATE ... ->създава обект (таблица, изглед, процедура, индекс и т.н.) 
* ALTER ...  ->променя съществуващ обект
* DROP ....  ->премахва обект 

### DML - Data Manipulation Language 

* SELECT ... ->чете данни от таблиците ( много таблици)
* INSERT ... ->добавя редове към таблица (върху 1 таблица или ограничен брой редове)
* UPDATE ... ->променя данни от таблица (върху 1 таблица или ограничен брой редове)
* DELETE ... ->изтрива редове от таблица (върху 1 таблица или ограничен брой редове)

## SELECT заявки

```sql
синтактична диаграма
SELECT * | col1, col2,... какво да се върне, като колони. Изброяваме в реда, в които искаме да ги видим
FROM  table(s) от коя таблица избираме
[WHERE col1 operator value1 ... ] ограничения на които трябва да отговаря, критерии на които да отговарят
```
| изключващо или
[] незадължит. елементи
звезда *  значи всички
колоните с малки букви или кемъл кейс. Select, FROM i т.н. с големи (добра практика)
SQL не е чувст. към ресгистър
Run statment = CTRL и Enter
F8 - вади история
-- коментар
```sql
SELECT *
FROM customers
---
SELECT country
, company_name
, contact_name
, phone
FROM customers

```

### WHERE клауза

* филтрира данните от таблиците включени в заявката
* при повече от едно условие, отделните условия се свързват с AND или OR

+=======================+=====================================================+
| WHERE                 | Действие                                            |
+=======================+=====================================================+
| [1] AND [2]           | Задължаващо И. трябва да са изпълнени и двете, ако едното не е изпълнено, не се връща нищо
+-----------------------+-----------------------------------------------------+
| [1] OR  [2]           | Или! може да са изпълнени [1] или [2] или и двете заедно, важното е поне едно да е изпълнено |
+-----------------------+-----------------------------------------------------+
| [1] OR  [2]  AND [3]  | Трябва да се изпълнени 1 и 3 или 2 и 3              |
+-----------------------+-----------------------------------------------------+
| ([1] OR [2] ) AND [3] | [1],[2]- едно от двете или двете заедно, [3]-винаги |
+-----------------------+-----------------------------------------------------+


**Кои редове ще се върнат в резултата?**

```sql
WHERE (1) OR (2) AND (3)  -- по подобие на 5 + 6 * 3
--     a      b       c
```

+----+---+---+---+
| a  | b | c | v |
+----+---+---+---+
| d  | b | c | v |
+----+---+---+---+
| d  | e | c | x |
+----+---+---+---+
| g  | b | c | v |
+----+---+---+---+
| a  | b | f | v |??????????????
+----+---+---+---+

```sql
WHERE ( (1) OR (2) ) AND (3)  -- по подобие на ( 5 + 6 ) * 3 => 5 * 3 + 6 * 3
--       a      b         c   -- или ((1) OR (2) ) AND (3) е като 
                              --     (1) AND (3) OR (2) AND (3)
```

+----+---+---+---+
| a  | b | c | v |
+----+---+---+---+
| d  | b | c | v |
+----+---+---+---+
| d  | e | c | x |
+----+---+---+---+
| g  | b | c | v |
+----+---+---+---+
| a  | b | f | x |
+----+---+---+---+




за различните видове данни се използват различни оператори
* оператори за филтриране на числа, дати и символи (char - ЕГН,Банкова сметка,..)
не са подходящи за свободен текст, а за фиксиран формат

+---------------------------------+-------------------------------------------+
| Оператори                       | Пример                                    |
+---------------------------------+-------------------------------------------+
| >, <, >=, <=, =, <> различно    | WHERE price > 20 AND price <> 50          |
+---------------------------------+-------------------------------------------+
| [NOT] IN ('val1','val2',....)   | WHERE itemID IN ('AA123','AB456','BD213') |
+---------------------------------+-------------------------------------------+
| [NOT] BETWEEN 'val1' AND 'val2' | WHERE price BETWEEN 5 AND 30              |
подходящо за ДАТИ И ЧИСЛА. ЗАТВОРЕН ИНТЕРВАЛ. ВКЛЮЧВА СЕ 5 И 30
+---------------------------------+-------------------------------------------+
[NOT] да не е/ да не съвпада
IN се използва за данни с дискретен характер. Те са фиксирани ст-сти/ номер поръчка, код, клиент,
продукт, не се изискава да има всичко зададено, може само едното да присъства. 
IN Позволява задаване на множество от ст-ст, може да съвпада с част.
Текстови данни:
- определен фиксиран формат
- свободен текст
Да се внимава с колини, които се срещат в повече от една таблица
```sql
SELECT order_id
, order_date
, ship_country
, ship_city
FROM orders
WHERE order_date >= '2015-07-01' AND order_date <= '2015-07-19'
не е нужно col по която филтрираме да присъства в резултата
Всичко което не е число се отделя в ед. кавички ' Съвръра прави разлика м/у ' и "
при различните сървъри датите се задават различно. При някои формата се задава
още при създаване на таблицата.
Оракъл съхранява датите, като числа. Настройва се от tools-pref-nls
ВАЖНО! РЕД НА ПИСАНЕ НА ЗАЯВКИ
1.FROM
2.WHERE
3.SELECT

-----
SELECT customer_id
, order_id
, order_date
, ship_country
FROM orders
WHERE customer_id IN (1,8,57)
---
SELECT customer_id
, customer_code
, company_name
, country
, city
FROM customers
WHERE customer_code IN ('ALFKI','BOLID','PARIS') --AND ...
-----
-- Същото като
SELECT customer_id
, customer_code
, company_name
, country
, city
FROM customers
WHERE customer_code = 'ALFKI' OR customer_code = 'BOLID' OR customer_code = 'PARIS' --AND ...
----
SELECT product_name
, quantity_per_unit
, unit_price
FROM products
WHERE unit_price BETWEEN 10 AND 20 
---
SELECT product_name
, quantity_per_unit
, unit_price
FROM products
WHERE unit_price NOT BETWEEN 10 AND 20
---
-- Същото като
SELECT product_name
, quantity_per_unit
, unit_price
FROM products
WHERE unit_price >= 10 AND unit_price <= 20  
---
-- заместване на NOT BETWEEN
SELECT product_name
, quantity_per_unit
, unit_price
FROM products
WHERE unit_price < 10 OR unit_price > 20  
```

* оператори за филтриране на текст (varchar, text)

+---------------------------------------+----------------------------------------------------+
| Оператори                             | Пример                                             |
+---------------------------------------+----------------------------------------------------+
| [NOT] LIKE 'pattern'                  | ```WHERE title LIKE 'The blue %'```Може да задаваме част от текста
използва се за прости търсения
+---------------------------------------+----------------------------------------------------+
| REGEXP_LIKE(column, pattern[, match]) | ```WHERE REGEXP_LIKE(company_name, '^A.*[ae]$')``` |
функция (колона, шаблон, [не е задължително, допълнит. настройка]/ 
тук не се използват символите % и _
column -колона , pattern - шаблон [, match] - незадължителна допълнителна настройка
ВАЖНО! В REGEXP_LIKE НЕ СЕ ИЗПОЛЗВАТ % И _ !!!!!!!!!!!!!!!!!!!!!
+---------------------------------------+----------------------------------------------------+
ВАЖНО!
% 0 ИЛИ ПОВЕЧЕ СИМВОЛА ОТ СТРАНАТА В КОЯТО Е ПОСТАВЕН
_ ТОЧНО 1 СИМВОЛ. НЕ МОЖЕ ДА СА 0
ИНТЕРВАЛА СЪЩО СЕ БРОИ СА СИМВОЛ
------------------------------------------------------------------------------------------------+
```sql
col = 'Maria' трябва да отговаря точно, няма да вкл. Мариана, Мария Попова, Марио и т.н.

'Mario'

col LIKE 'M%' => 'M', 'Ma', 'Mab', ...


col LIKE 'M_' => 'Ma', 'Mb', ..., 'M ', но не 'М' или 'Маb'
```

```sql
SELECT customer_code
, contact_name
FROM customers
WHERE contact_name LIKE 'M%'
----
SELECT customer_code
, contact_name
FROM customers
WHERE contact_name LIKE 'M_r%'
```

```sql
'Xyz Abcd' ТЪРСИМ ФАМИЛИЯ, КОЯТО започва с А и някакво име
'__% A___%'ДА

' Асен Петров'
'Мария Петров а'

LIKE ''

1) A% -НЕ 
2) _% A% -НЕ
3) __ A% -НЕ
4) % A% -НЕ
```

```sql
SELECT customer_code
, contact_name
FROM customers
WHERE contact_name LIKE '__% A___%'
```
композитна колна- съсржа повече от едно нещо
според теорията на БД всяка колона трябва да съдържа единична ст-ст.
напр. код на тел е една колна, а самия тел - друга
ако ще се търси по дадена кол. то е добре тя да не е композитна
------------------------------------------------------------------------+
                             REGEXP_LIKE
* основни оператори за съставяне на регулярни изрази (pattern)


+----------+-------------------------------------+------------------+
| Оператор | Действие                            | Пример           |
+----------+-------------------------------------+------------------+
| ^        | редът да започва с онова
             което е след човката                | ```'^Maria'```   |
+----------+-------------------------------------+------------------+
| $        | редът да завършва с това преди долар| ```'son$'```     |
+----------+-------------------------------------+------------------+
| .        | замества точно 1 символ, но всеки   | ```'.*'```       |специален символ, замества само 1символ, но той може да всеки
+----------+-------------------------------------+------------------+
| {n}      | n - пъти предходното ПОСЛЕДОВАТЕЛНО????
| {n,m}    | поне n пъти, но не повече от m пъти | ```'^.n{1,2}'``` |
| {,m}     | не повече от m пъти                 |                  |
| {n,}     |  поне n пъти, не по-малко от n пъти |                  |
+----------+-------------------------------------+------------------+
| [списък] | един от символите в списъка         | ```'^Mar[yt]'``` |
+----------+-------------------------------------+------------------+
| *        | 0 или повече срещания на преходното           
+----------+-------------------------------------+------------------+
| ?        | 0 или 1 срещане срещания на преходното        
+----------+-------------------------------------+------------------+
| +        | 1 или повече срещания срещания на преходното         
+----------+-------------------------------------+------------------+
  ()          символ за групиране ^(A|M)
+----------+-------------------------------------+------------------+
  | или
  +----------+-------------------------------------+------------------+
  [^] тук ^ си сменя смисъла и значи да не е. ИГРАЕ РОЛЯ НА ОТРИЦАНИЕ
  +----------+-------------------------------------+------------------+
  [] МОЖЕ ДА СЕ СЛОЖИ ПОРЕДИЦА ОТ СИМВОЛИ, НО ЗАМЕСТВА 1  [cty]- една от тези
    +----------+-------------------------------------+------------------+ 
	\d цифра
	 +----------+-------------------------------------+------------------+ 
	 \d не е цифра
	  +----------+-------------------------------------+------------------+ 
	  \w  дума
	   +----------+-------------------------------------+------------------+ 
	   \W не е дума
	    +----------+-------------------------------------+------------------+ 
		\s интервал
		 +----------+-------------------------------------+------------------+  
		 \S не е интервал
	 
* допълнителни настройки на процеса на търсене (match)
В MATCH МОЖЕ ДА СЕ ИЗПБРОЯВАТ ПАРАМЕТРИ

+-------+----------------------------------+
| match | действие                         |
+-------+----------------------------------+
| i     | да НЕ е чувствително към аА регистър  
+-------+----------------------------------+
| c     | да Е чувствително към аА         |
+-------+----------------------------------+
| n     | да третира . като част от текста |
+-------+----------------------------------+
| m     | текстът е многоредов. Да търси по всички редове   
+-------+----------------------------------+

```sql
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^A')
Да започва с А
'ana' някъде в текста да има ana
---
не!
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^A|^M')
да започва с А или с М, но това не е удачен вариант. 
Трябва да се обедини със скоби. Виж Долния пример
---
да!                        
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^(A|M)')
---
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, 'er$')
ВСИЧКО което завършва на er
---
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^An.')
---
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, 'n{2}|a{2}|t{2}') една от трите букви да се повтаря ТОЧНО два пъти ПОСЛЕДОВАТЕЛНО ЛИ?!
---
-- 'Xyz Bennett'
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, 'n{2}.t{2}$') Два пъти n, . замества всеки символ и 2 пъти t
----
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^Mar[ity]') Да започва с MAR и после да има една от трите букви i,t или y
----
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^Mar[a-zA-Z0-9 ]') Да започва с MAR и после може да има от а до я с малки и големи,всички числа и интервал
-----
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^Mar[^ty]') Да започва с MAR и следващата да НЕ Е t или у
----
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, ' A[a-z]+$')
итревал А, едно или повече срещания (+) на всички букви и символ за край. Връща всички фамилии, които започват с А
----
SELECT contact_name
FROM customers
WHERE REGEXP_LIKE(contact_name, '^\w+\s\w+\s\w+$')
Търсим хора с три имена, w e дума, + за един или повече срещания, s за спейс и накрая $ за край
/w дума
/W не е дума
/s спейс
/S не е спейс
/d цифра
/D не е цифра
```

1. https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix003.htm#SQLRF55544
2. https://regexr.com/ тренер.Да сменя настройката от JS на PCRE


```sql
ALTER SESSION SET NLS_COMP=LINGUISTIC;

ALTER SESSION SET NLS_SORT=BINARY_CI;
```


## Свързване на таблици в SELECT

* свързвайки таблици в SELECT можем да комбинираме редовете и колоните от 2 или 
повече таблици

### Видове свързвания

* INNER JOIN (Вътрешно съединение) - връща само данните за които има движение. Peter i Anna няма да се върнат

В резултата ще се върнат всички редове от таблица А и таблица В, за които е 
изпълнено **B.FK = A.PK** 


  (pk)  user                   (pk)     posts     (fk)
+-----+-----------+           +----+-------------+------+
| UID | UserName  |           | PID| Post        | UID  |
+-----+-----------+           +----+-------------+------+
|  1  |  John     |           | 1  |Hello ...    |  1   |
+-----+-----------+           +----+-------------+------+
|  2  |  Maria    |           | 2  |MySQL is...  |  2   |
+-----+-----------+---------< +----+-------------+------+
|  3  |  Peter    |           | 3  |SQL query... |  1   |
+-----+-----------+           +----+-------------+------+
|  4  |  Anna     |           | 4  |PHP driver...|  2   |
+-----+-----------+           +----+-------------+------+

Резултат:

+-----------+-------------+------+
| UserName  | Post        | UID  |
+-----------+-------------+------+
|  John     |Hello ...    |  1   |
+-----------+-------------+------+
|  Maria    |MySQL is...  |  2   |
+-----------+-------------+------+
|  John     |SQL query... |  1   |
+-----------+-------------+------+
|  Maria    |PHP driver...|  2   |
+-----------+-------------+------+

* псевдоними на таблици

```sql
SELECT table1.column1, table2.column2, table2.column5
FROM table1 
       INNER JOIN 
     table2 
     ON table2.fk_column = table1.pk_column
```

```sql
FROM BANKSTATEMENTLINEBANKDOCUMENTINFORMATION
```

```sql
SELECT t1.column1, t2.column2, t2.column5
FROM table1 t1 
       INNER JOIN 
     table2 t2
     ON t2.fk_column = t1.pk_column
	  - t1 e псевдоним и е валиден само докато заявката се изпълнява. Да не се бърка със синоним
```

```sql
SELECT t1.customer_code
, t1.company_name
, t2.order_id
, t2.order_date
, t2.ship_country
, t1.country
FROM customers t1
        INNER JOIN
     orders t2
        ON t2.customer_id = t1.customer_id
WHERE t1.customer_code IN ('ALFKI','BOLID','PARIS')
---
SELECT t1.customer_id
, t1.order_id
, t1.order_date
, t3.product_name
, t2.quantity
, t2.unit_price
FROM orders t1
        INNER JOIN
     order_details t2
        ON t2.order_id = t1.order_id
        INNER JOIN
     products t3
        ON t2.product_id = t3.product_id
WHERE t1.customer_id = 1 --ALFKI
ORDER BY t1.order_id
Когато свързваме таблици, трябва да минем през всички свързващи,, които стоят по пътя, като търсим мин. брой таблици
Не могат да се прескачат свързващи и да се свързват таблици без обща колона.
ВАЖНО!Всяка следваща таблица се свързва с множеството от предходните, които сме свързали. 
3 се свързва с множеството от 1 и 2, а не само с 2.
---
SELECT t1.customer_id
, t1.order_id invoiceNo
, t1.order_date
, t3.product_name
, t2.quantity
, t2.unit_price 
, t2.quantity * t2.unit_price total -- може и така: as total
, t2.quantity * t2.unit_price * 1.2 totalVAT
FROM orders t1
        INNER JOIN
     order_details t2
        ON t2.order_id = t1.order_id
        INNER JOIN
     products t3
        ON t2.product_id = t3.product_id
WHERE t1.customer_id = 1 --ALFKI
ORDER BY t1.order_id
Могат да се налагат ограничения във сяка таблица вкл. в FROM, дори в/у колони, които не се виждат в момента
---
SELECT t1.customer_id
, t1.order_id invoiceNo
, t1.order_date
, t3.product_name
, t2.quantity
, t2.unit_price 
, t2.quantity * t2.unit_price total -- може и така: as total
, t2.quantity * t2.unit_price * 1.2 totalVAT
FROM orders t1
        INNER JOIN
     order_details t2
        ON t2.order_id = t1.order_id
        INNER JOIN
     products t3
        ON t2.product_id = t3.product_id
WHERE t1.customer_id = 1 --ALFKI
        AND
      t2.quantity * t2.unit_price < 100
ORDER BY total DESC
Псевдонимите на колони имат мн. по-ограничено действие от тези на таблици
as се изсиква само при някои сървъри
total е изчислима колона, получва се от ед. цена и количество, като може тези две колони да не са извикани
 Което по принцип не е прието, но се налага понякога
 ВАЖНО! ПОСЛЕДНОВАТЕЛНОСТ НА ИЗПЪЛНЕНИЕ НА ЗАЯВКА!
 1. FROM
 2. WHERE
 3. SELECT
 4. ВСИЧКО ПОД WHERE СЕ ИЗПЪЛНЯВА СЛЕД СЕЛЕКТ И ТОГАВА МОЖЕ ДА ИЗВИКВАМЕ ПСЕВДОНИМИ НА КОЛОНИ, 
 ЗАЩОТО ТЕ ВЕЧЕ СА ДЕФИНИРАНИ И ПРОЧЕТЕНИ
 ORDER Е ЗА СОРТИРАНЕ
```

```sql
ПО ПОДРАЗБИРАНЕ РЕДА Е asc - възходящ/ desc- нискодящ
ORDER BY col1 [ASC]|DESC, col2 [ASC]|DESC, ...
--или
извикване според поредния номер в селекст частта
ORDER BY 1 [ASC]|DESC, 2 [ASC]|DESC, ...
```
ВАЖНО! ВИНАГИ СЕ ЗАПОЧВА ОТ КОЛОНА 1 ИЛИ АКО СА ДВЕ, ТО ЗАПОЧВАМЕ ОТ ТОВА, ЗА КОЕТО НИ ПИТАТ


ЛЕКЦИЯ 4 

* OUTER JOIN  (Външно съвединение )
  + LEFT OUTER JOIN - ляво външно съединение

  + RIGHT OUTER JOIN - дясно външно съединение

  + FULL OUTER JOIN - ляво + дясно външно съединение


* **LEFT** или **RIGHT** се определя от мястото на таблицата, която е страна 1 
във връзката между таблиците

* **LEFT**: В резултата се връщат всички данни от А (без значение дали имат 
свързани записи в B) със съответстващите данни от В като за редовете от A, които 
нямат свързани записи в B, клетките в колоните от B са празни.
NULL- означава, че няма данни, не значи 0
tool-pref-DB - adv
ctrl + / - коментар

  (pk)  user                   (pk)     posts     (fk)
+-----+-----------+           +----+-------------+------+
| UID | UserName  |           | PID| Post        | UID  |
+-----+-----------+           +----+-------------+------+
|  1  |  John     |           | 1  |Hello ...    |  1   |
+-----+-----------+           +----+-------------+------+
|  2  |  Maria    |           | 2  |MySQL is...  |  2   |
+-----+-----------+---------< +----+-------------+------+
|  3  |  Peter    |           | 3  |SQL query... |  1   |
+-----+-----------+           +----+-------------+------+
|  4  |  Anna     |           | 4  |PHP driver...|  2   |
+-----+-----------+           +----+-------------+------+

Резултат:
  (pk)                           (fk)
+-----+-----------+-------------+------+
| UID | UserName  | Post        | UID  |
+-----+-----------+-------------+------+
|  1  |  John     |Hello ...    |  1   |
+-----+-----------+-------------+------+
|  2  |  Maria    |MySQL is...  |  2   |
+-----+-----------+-------------+------+
|  1  |  John     |SQL query... |  1   |
+-----+-----------+-------------+------+
|  2  |  Maria    |PHP driver...|  2   |
+-----+-----------+-------------+------+
|  3  |  Peter    |             |      |
+-----+-----------+-------------+------+
|  4  |  Anna     |             |      |
+-----+-----------+-------------+------+

* ляво или дясно външно съединение?

```sql
       1   LEFT                  M
FROM tab1  ....     OUTER JOIN tab2
       M   RIGHT                 1
```

```sql
SELECT t1.customer_code
, t1.country
, t2.order_id
, t2.order_date
, t2.ship_country
FROM customers t1 
        LEFT OUTER JOIN 
     orders t2
        ON t2.customer_id = t1.customer_id
WHERE t1.customer_code IN ('ALFKI','BOLID','PARIS')
ORDER BY 1
---
DESCRIBE orders
----
-- Грешен тип на свързване 
SELECT t1.customer_code
, t1.country
, t2.order_id
, t2.order_date
, t2.ship_country
FROM customers t1 
        RIGHT OUTER JOIN 
     orders t2
        ON t2.customer_id = t1.customer_id
WHERE t1.customer_code IN ('ALFKI','BOLID','PARIS')
ORDER BY 1
----
-- Грешен начин на филтриране
SELECT t1.customer_code
, t1.country
, t2.order_id
, t2.order_date
, t2.ship_country
FROM customers t1 
        LEFT OUTER JOIN 
     orders t2
        ON t2.customer_id = t1.customer_id
WHERE t1.customer_code IN ('ALFKI','BOLID','PARIS')
        AND
      t2.order_date BETWEEN '2016-01-01' AND '2016-12-31'
       
ORDER BY 1
----
SELECT t1.customer_code
, t1.country
, t2.order_id
, t2.order_date
, t2.ship_country
FROM customers t1 
        LEFT OUTER JOIN 
     orders t2
        ON t2.customer_id = t1.customer_id
WHERE t1.customer_code IN ('ALFKI','BOLID','PARIS')
        AND
      ( 
        t2.order_date BETWEEN '2016-01-01' AND '2016-12-31'
        OR
        t2.order_date IS NULL)
ORDER BY 1
```

* изключение от правилото за LEFT/RIGHT

  (pk)  user                   (pk)     posts     (fk)
+-----+-----------+           +----+-------------+------+
| UID | UserName  |           | PID| Post        | UID  |
+-----+-----------+           +----+-------------+------+
|  1  |  John     |           | 1  |Hello ...    |  1   |
+-----+-----------+           +----+-------------+------+
|  2  |  Maria    |           | 2  |MySQL is...  |  2   |
+-----+-----------+---------< +----+-------------+------+
|  3  |  Peter    |           | 3  |SQL query... |  1   |
+-----+-----------+           +----+-------------+------+
|  4  |  Anna     |           | 4  |PHP driver...|      |
+-----+-----------+           +----+-------------+------+

Резултат:

 (pk)                         
+-----+---------------+----------+
| PID | Post          | UserName |
+-----+---------------+----------+
| 1   | Hello ...     | John     |
+-----+---------------+----------+
| 2   | MySQL is...   | Maria    |
+-----+---------------+----------+
| 3   | SQL query...  | John     |
+-----+---------------+----------+
| 4   | PHP driver... |          |
+-----+---------------+----------+

* FULL OUTER JOIN

  (pk)  user                   (pk)     posts     (fk)
+-----+-----------+           +----+-------------+------+
| UID | UserName  |           | PID| Post        | UID  |
+-----+-----------+           +----+-------------+------+
|  1  |  John     |           | 1  |Hello ...    |  1   |
+-----+-----------+           +----+-------------+------+
|  2  |  Maria    |           | 2  |MySQL is...  |  2   |
+-----+-----------+---------< +----+-------------+------+
|  3  |  Peter    |           | 3  |SQL query... |  1   |
+-----+-----------+           +----+-------------+------+
|  4  |  Anna     |           | 4  |PHP driver...|      |
+-----+-----------+           +----+-------------+------+

Резултат:
                             
+-----+---------------+----------+
| UID | Post          | UserName |
+-----+---------------+----------+
| 1   | Hello ...     | John     |
+-----+---------------+----------+
| 2   | MySQL is...   | Maria    |
+-----+---------------+----------+
| 1   | SQL query...  | John     |
+-----+---------------+----------+
|     | PHP driver... |          |
+-----+---------------+----------+
| 3   |               | Peter    |
+-----+---------------+----------+
| 4   |               | Anna     |
+-----+---------------+----------+

## Изчисления в SELECT

* независимо от това какво и как изчисляваме, данните в таблиците **не се променят**

### Оператори

* аритметични: +, -, * , /
* конкатенация:  ||

```sql
MS SQL, Sybase: SELECT firstname + ' ' + lastname ...
MySQL: SELECT concat(firstname, ' ', lastname) ...
MySQL: SELECT concat_ws(' ', firstname, lastname) ...
```

```sql
SELECT firstname || ' ' || lastname Employee
FROM employees
----
SELECT company_name || ' (' || country || ', ' || city || ')' Customer
FROM customers

```

https://docs.oracle.com/cd/E11882_01/server.112/e41084/toc.htm

### Функции (Single-row functions)

* математически

+--------------+------------------------------------+
| ROUND(n[,m]) | закръглява n до m-я знак           |
+--------------+------------------------------------+
| TRUNC(n[,m]) | "реже" от n m десетични знака      |
+--------------+------------------------------------+
| CEIL(n)      | закръглява до нагоре до цяло число |
+--------------+------------------------------------+
| FLOOR(n)     | закръглява надолу до цяло число    |
+--------------+------------------------------------+

```sql
SELECT product_name
, unit_price 
, unit_price * 1.95583 priceBGN
, ROUND(unit_price * 1.95583, 2) priceRnd 
, TRUNC(unit_price * 1.95583, 2) priceTrn 
, CEIL(unit_price * 1.95583) priceC 
, FLOOR(unit_price * 1.95583) priceF 
FROM products
```

* текст

+----------------------------------+-----------------------------------------------------+
| SUBSTR(txt, p[, l])              | връща от позиция p в txt  l символа                 |
+----------------------------------+-----------------------------------------------------+
| INSTR(txt, s[, p])               | връща позицията на s в txt, започвайки от позиция p |
+----------------------------------+-----------------------------------------------------+
| UPPER(txt)/LOWER(txt)            | преобразува в главни/малки букви txt                |
+----------------------------------+-----------------------------------------------------+
| REPLACE(txt,v)                   | замества v в txt                                    |
+----------------------------------+-----------------------------------------------------+
| REGEXP_REPLACE(txt,'reg','with') | замества с помощта на регулярен израз               |
+----------------------------------+-----------------------------------------------------+

```sql
-- Maria Anders -> M. Anders
--Maria Anders -> M. Anders
SELECT contact_name
, SUBSTR(contact_name,1,1)
 || '.'
 || SUBSTR(contact_name, INSTR(TRIM(contact_name), ' ', -1)) Contact
FROM customers
---
--Maria Anders -> M. Anders
SELECT contact_name
, REGEXP_REPLACE(contact_name, '^(\w).+\s(\w+)\s?$', '\1. \2') Contact
FROM customers

```
ot doma6no SELECT *
FROM Products
WHERE unit LIKE '%oz%tt%' and unit not like'%8%';

REGEXP_LIKE \d+\s\-\s\d+\s\w+\s\w+$
